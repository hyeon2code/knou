package Operator;

/**
 * File Name: Operator.java
 * Create by: Dohyeon Kwon (playdev7@gmail.com)
 * Create on: December 26. 2023
 * Last Edited: December 26. 2023
 * Summary: Java의 연산자들을 활용하여 연산을 진행하는 프로그램
 */
public class Operator {
	public static void main(String args[]) {	
		// Java의 연산자 종류로는 산술연산자, 비교연산자, 논리연산자, 비트연산자, 대입연산자, 캐스팅연산자, 기타 연산자가 있다.
		
		// 산술연산자
		// 산술연산자는 사칙연산을 표현하기 위한 연산자이다.
		// 산술연산자는 이항연산자와 단항연산자로 나뉜다.
		int a = 1, b = 2;
		// 이항산술연산자 예시.
		int result = a + b; // a와 b를 더한다.
		result = a - b;		// a에서 b를 뺀다.
		result = a * b; 	// a와 b를 곱한다.
		result = a / b;		// a에서 b를 나눈 "몫"을 구한다.
		result = a % b;		// a에서 b를 나눈 나머지를 구한다. 모듈로 연산이라고 한다.
		// 단항산술연산자 예
		result = +a;		// a의 부호를 바꾸지 않는다.
		result = -a;		// a의 부호를 반대로 바꾼다.
		result = ++a;		// 현재 a의 값을 1 증가시키고 그 결과를 result에 저장한다. 전위연산자라고 한다.
		result = --a;		// 현재 a의 값을 1 감소시키고 그 결과를 result에 저장한다.
		result = a++;		// 현재 a의 값을 result에 저장하고 a의 값을 1 증가시킨다. 후위연산자라고 한다.
		result = a--;		// 현재 a의 값을 result에 저장하고 a의 값을 1 감소시킨다.
		
		
		// 비교연산자
		// 비교연산자는 두 개의 피연산자를 다양하게 비교하기 위한 연산자이다.
		// 대소비교는 피연산자가 모두 숫자일때만 가능하고, 같고 다름을 비교하는 연산은 어떠한 자료형이어도 무관하다.
		boolean resultFlag;
		resultFlag = a > b; // a가 b보다 큰지 참/거짓 값을 resultFlag에 저장한다.
		resultFlag = 2 == 3; // 2와 3이 같은지 참/거짓 값을 resultFlag에 저장한다.
		// 또한 하위 인스턴스인지 확인하는 instanceof 연산자가 있다.
		// a instance of b 꼴로 a가 b의 하위 인스턴스인지 비교할 수 있다.
		
		
		// 논리연산자 
		// 논리연산자는 피연산자가 boolean 자료형일 때 논리연산을 수행하는 연산자이다.
		boolean p = true, q = false;
		// 논리연산자를 두 개 사용할 경우 흡수법칙이 적용된다.
		resultFlag = p && q; 		// p와 q의 AND 연산을 수행한 결과를 resultFlag에 저장한다. p가 false면 비교없이 바로 false를 저장한다.
		resultFlag = p || q; 		// p와 q의 OR 연산을 수행한 결과를 resultFlag에 저장한다. p가 true면 비교없이 바로 true를 저장한다.
		// 논리연산자를 하나만 적을 경우 항상 두 피연산자를 모두 참조한 다음 비교한다.
		resultFlag = p & q;  		// p와 q의 AND 연산 결과를 resultFlag에 저장한다.
		resultFlag = p | q;  		// p와 q의 OR 연산 결과를 resultFlag에 저장한다.
		resultFlag = p ^ q; 		// p와 q의 XOR 연산 결과를 resultFlag에 저장한다.
		resultFlag = !p;			// p의 부정을 resultFlag에 저장한다.
		// 삼항연산자로서 두 피연산자의 비교 결과가 참이면 a, 거짓이면 b를 대입하는 연산자가 존재한다.
		result = p != q? a:b;	// p와 q가 다르면 a를, 거짓이면 b를 result에 저장.
		
		
		// 비트연산자
		// 비트연산자는 비트단위 연산을 수행하며, int인 피연산자에 대해서만 적용 가능하다.
		// 비트간의 연산을 진행하는 비트논리연산자와 비트를 특정 방향으로 쉬프트하는 비트이동연산자가 존재한다.
		
		// 비트논리연산자
		// int형 자료에 논리기호를 붙여주면 비트논리연산을 수행한다.
		// int형 정수 리터럴을 이진수로 변환한 다음 1은 true, 0은 flase로서 비트 칸마다 논리연산을 수행한다.
		// 논리연산 수행 결과는 다시 십진수 int로 변환된다.
		result = 9 & 5;			// 1001 AND 0101 로서 각 칸마다 AND연산 => 0001 => 십진수 1
		result = 9 | 5;			// 1001 OR 0101 로서 각 칸마다 OR연산 => 1101 => 십진수 13
		result = 9 ^ 5;			// 1001 XOR 0101 로서 각 칸마다 XOR연산 => 1100 => 십진수 12
		result = ~9;			// not 1001 로서 각 칸마다 비트 반전 => 0110 => 십진수 6
		
		// 비트이동연산자 
		// 1. int형 피연산자 a를 이진수로 바꿈
		// 2. (1)을 b만큼 쉬프트(32칸을 초과하는 숫자는 버려지고 b만큼의 공백이 생김)
		// 3. 쉬프트 결과를 십진수로 변환하여 대입
		// 상황에 따라서 MSB가 바뀜. 
		result = 9 << 3;	// 00000000 00000000 00000000 00001001을 3칸 왼쪽으로 쉬프트하고 공백을 0으로 채움 => 00000000 00000000 00000000 01001000 => 십진수 72
		result = 1073741824 << 1;	// 01000000 00000000 00000000 00000000을 1칸 왼쪽으로 쉬프트하고 공백을 0으로 채움 => 10000000 00000000 00000000 00000000 => 십진수 -2147483648
		result = 1610612736 << 1;	// 01100000 00000000 00000000 00000000을 1칸 왼쪽으로 쉬프트하고 공백을 0으로 채움 => 11000000 00000000 00000000 00000000 => 십진수 -1073741824
		// 오른쪽 쉬프트는 부호의 개수에 따라 MSB를 유지하거나 유지하지 않음
		// 두 개일 경우 MSB를 제외한 비트만 쉬프트.
		result = -1073741824 >> 1;	// 11000000 00000000 00000000 00000000에서 MSB 제외하고 1칸 오른쪽 쉬프트 및 공백을 0으로 채움 => 10100000 00000000 00000000 00000000 => 십진수 -536870912
		result = -1073741824 >> 2;	// 11000000 00000000 00000000 00000000에서 MSB 제외하고 2칸 오른쪽 쉬프트 및 공백을 0으로 채움 => 10010000 00000000 00000000 00000000 => 십진수 -268435456
		result = -1073741824 >> 3;	// 11000000 00000000 00000000 00000000에서 MSB 제외하고 3칸 오른쪽 쉬프트 및 공백을 0으로 채움 => 10001000 00000000 00000000 00000000 => 십진수 -134217728
		// 세 개일 경우 MSB까지 포함하여 쉬프트하고 공백을 0으로 채움
		result = -1073741824 >>> 1;	// 11000000 00000000 00000000 00000000 전체를 1칸 오른쪽 쉬프트 및 공백을 0으로 채움 => 01100000 00000000 00000000 00000000 => 십진수 1610612736
		result = -1073741824 >>> 2;	// 11000000 00000000 00000000 00000000 전체를 2칸 오른쪽 쉬프트 및 공백을 0으로 채움 => 00110000 00000000 00000000 00000000 => 십진수 805306368		
	}
}
